<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Introduction</title>
</head>


<body>
<div class="head">
<h1>Theory Introduction</h1>
</div>

<pre class="source"><span class="comment1"><span>(</span><span>*</span><span> 
    This file is a part of IsarMathLib - 
    a library of formalized mathematics for Isabelle/Isar.

    Copyright (C) 2008-2014  Slawomir Kolodynski

    This program is free software; Redistribution and use in source and binary forms, 
    with or without modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright notice, 
   this list of conditions and the following disclaimer in the documentation and/or 
   other materials provided with the distribution.
   3. The name of the author may not be used to endorse or promote products 
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹</span><span>Introduction to the IsarMathLib project</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>theory</span></span></span><span> </span><a href="Introduction.html"><span>Introduction</span></a><span> </span><span class="keyword2"><span class="keyword"><span>imports</span></span></span><span> </span><a href="../../FOL/ZF/equalities.html"><span>ZF.equalities</span></a><span>

</span><span class="keyword2"><span class="keyword"><span>begin</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span class="quoted"><span class="plain_text"><span>‹</span><span>This theory does not contain any formalized mathematics used in 
</span><span>  other theories, but is an introduction to IsarMathLib project.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span class="quoted"><span class="plain_text"><span>‹</span><span>How to read IsarMathLib proofs - a tutorial</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span class="quoted"><span class="plain_text"><span>‹</span><span>Isar (the Isabelle's formal proof language) was designed to be similar
</span><span>  to the standard language of mathematics. Any person able to read proofs in
</span><span>  a typical mathematical paper should be able to read and understand
</span><span>  Isar proofs without having to learn a special proof language. 
</span><span>  However, Isar is a formal proof language and as such it does contain a 
</span><span>  couple of constructs whose meaning is hard to guess. In this tutorial 
</span><span>  we will define a notion and prove an example theorem about that notion,
</span><span>  explaining Isar syntax along the way. This tutorial may also serve as a 
</span><span>  style guide for IsarMathLib contributors. Note that this tutorial
</span><span>  aims to help in reading the presentation of the Isar language that is used
</span><span>  in IsarMathLib proof document and HTML rendering on the 
</span><span>  FormalMath.org site, but does not teach how to write proofs that can be
</span><span>  verified by Isabelle. This presentation is different than the source 
</span><span>  processed by Isabelle (the concept that the source and presentation 
</span><span>  look different should be familiar to any LaTeX user). To learn
</span><span>  how to write Isar proofs one needs to study the source of this tutorial as well.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span class="quoted"><span class="plain_text"><span>‹</span><span>The first thing that mathematicians typically do is to define
</span><span>  notions. In Isar this is done with the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>definition›</span></span></span><span> keyword.
</span><span>  In our case we define a notion of two 
</span><span>  sets being disjoint. We will use the infix notation, i.e. the string
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>{is disjoint with}›</span></span></span><span> put between two sets to denote our notion 
</span><span>  of disjointness. 
</span><span>  The left side of the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>≡›</span></span></span><span> symbol is the notion 
</span><span>  being defined, the right side says how we define it. In Isabelle/ZF </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>0›</span></span></span><span>
</span><span>  is used to denote both zero (of natural numbers) and the empty set, which is
</span><span>  not surprising as those two things are the same in set theory.</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="Introduction.AreDisjoint_def|fact"><span class="entity_def" id="Introduction.AreDisjoint_def|thm"><span class="entity_def" id="Introduction.AreDisjoint_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> 
  </span><span class="entity"><span class="entity_def" id="Introduction.AreDisjoint|const"><span>AreDisjoint</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>infix</span></span></span><span> </span><span class="quoted"><span>"</span><span class="keyword1"><span>{is</span></span><span> </span><span class="keyword1"><span>disjoint</span></span><span> </span><span class="keyword1"><span>with}</span></span><span>"</span></span><span> 90</span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span class="bound"><span class="entity"><span>A</span></span></span></span><span> </span><span class="keyword1"><span class="free"><span>{is</span></span></span><span> </span><span class="keyword1"><span class="free"><span>disjoint</span></span></span><span> </span><span class="keyword1"><span class="free"><span>with}</span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>B</span></span></span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>A</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.Int|const"><span>∩</span></a></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>B</span></span></span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/IFOL.html#IFOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.zero|const"><span>0</span></a></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span class="quoted"><span class="plain_text"><span>‹</span><span>We are ready to prove a theorem. Here we show that the relation
</span><span>  of being disjoint is symmetric. We start with one of the keywords
</span><span>  ''theorem'', ''lemma'' or ''corollary''. In Isar they are synonymous.
</span><span>  Then we provide a name for the theorem. In standard mathematics 
</span><span>  theorems are numbered. In Isar we can do that too, but it is
</span><span>  considered better to give theorems meaningful names.
</span><span>  After the ''shows'' keyword we give the statement to show. The 
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>⟷›</span></span></span><span> symbol denotes the equivalence in Isabelle/ZF. Here
</span><span>  we want to show that "A is disjoint with B iff and only if B is disjoint 
</span><span>  with A". To prove this fact we show two implications - the first one that 
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A {is disjoint with} B›</span></span></span><span> implies </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>B {is disjoint with} A›</span></span></span><span>
</span><span>  and then the converse one. Each of these implications is formulated
</span><span>  as a statement to be proved and then proved in 
</span><span>  a subproof like a mini-theorem.
</span><span>  Each subproof uses a proof block to show the implication. Proof blocks
</span><span>  are delimited with curly brackets in Isar. 
</span><span>  Proof block is one of the constructs that
</span><span>  does not exist in informal mathematics, so it may be confusing. 
</span><span>  When reading a proof containing a proof block I suggest to focus first 
</span><span>  on what is that we are proving in it. This can be done by looking
</span><span>  at the first line or two of the block and then at the last statement. 
</span><span>  In our case the block starts with 
</span><span>  "assume </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A {is disjoint with} B›</span></span></span><span> and the last statement
</span><span>  is "then have </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>B {is disjoint with} A›</span></span></span><span>". It is a typical pattern 
</span><span>  when someone needs to prove an implication: one assumes the antecedent
</span><span>  and then shows that the consequent follows from this assumption.
</span><span>  Implications are denoted with the 
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>⟶›</span></span></span><span> symbol in Isabelle. 
</span><span>  After we prove both implications we collect them 
</span><span>  using the ''moreover'' construct. The keyword ''ultimately''
</span><span>  indicates that what follows is the conclusion of the statements 
</span><span>  collected with ''moreover''. The ''show'' keyword is like ''have'',
</span><span>  except that it indicates that we have arrived at the claim of the 
</span><span>  theorem (or a subproof).</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>theorem</span></span></span><span> </span><span class="entity_def" id="Introduction.disjointness_symmetric|fact"><span class="entity_def" id="Introduction.disjointness_symmetric|thm"><span>disjointness_symmetric</span></span></span><span class="main"><span>:</span></span><span> 
  </span><span class="keyword2"><span class="keyword"><span>shows</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>A</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/IFOL.html#IFOL.iff|const"><span>⟷</span></a></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>A</span></span><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span>
  </span><span class="keyword1"><span class="command"><span>have</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>A</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/IFOL.html#IFOL.imp|const"><span>⟶</span></a></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>A</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span>
    </span><span class="keyword1"><span class="command"><span>{</span></span></span><span> </span><span class="keyword3"><span class="command"><span>assume</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>A</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>B</span></span><span>"</span></span></span><span>
      </span><span class="keyword1"><span class="command"><span>then</span></span></span><span> </span><span class="keyword1"><span class="command"><span>have</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.Int|const"><span>∩</span></a></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/IFOL.html#IFOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.zero|const"><span>0</span></a></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint_def|fact"><span>AreDisjoint_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
      </span><span class="keyword1"><span class="command"><span>hence</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>B</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.Int|const"><span>∩</span></a></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/IFOL.html#IFOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.zero|const"><span>0</span></a></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><a class="entity_ref" href="../../FOL/ZF/ISABELLE_HOME/src/Provers/clasimp.ML.html#FOL.auto|method"><span class="operator"><span>auto</span></span></a><span>
      </span><span class="keyword1"><span class="command"><span>then</span></span></span><span> </span><span class="keyword1"><span class="command"><span>have</span></span></span><span>  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>B</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>A</span></span><span>"</span></span></span><span>
        </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint_def|fact"><span>AreDisjoint_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
    </span><span class="keyword1"><span class="command"><span>}</span></span></span><span> </span><span class="keyword3"><span class="command"><span>thus</span></span></span><span> </span><span class="var"><span class="quoted"><span class="var"><span>?thesis</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
  </span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>moreover</span></span></span><span> </span><span class="keyword1"><span class="command"><span>have</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>B</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/IFOL.html#IFOL.imp|const"><span>⟶</span></a></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>B</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span>
    </span><span class="keyword1"><span class="command"><span>{</span></span></span><span> </span><span class="keyword3"><span class="command"><span>assume</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>B</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>A</span></span><span>"</span></span></span><span>
      </span><span class="keyword1"><span class="command"><span>then</span></span></span><span> </span><span class="keyword1"><span class="command"><span>have</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>B</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.Int|const"><span>∩</span></a></span><span> </span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/IFOL.html#IFOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.zero|const"><span>0</span></a></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint_def|fact"><span>AreDisjoint_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
      </span><span class="keyword1"><span class="command"><span>hence</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>A</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.Int|const"><span>∩</span></a></span><span> </span><span class="free"><span>B</span></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/IFOL.html#IFOL.eq|const"><span>=</span></a></span><span> </span><span class="main"><a class="entity_ref" href="../../FOL/ZF/ZF_Base.html#ZF_Base.zero|const"><span>0</span></a></span><span>"</span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><a class="entity_ref" href="../../FOL/ZF/ISABELLE_HOME/src/Provers/clasimp.ML.html#FOL.auto|method"><span class="operator"><span>auto</span></span></a><span>
      </span><span class="keyword1"><span class="command"><span>then</span></span></span><span> </span><span class="keyword1"><span class="command"><span>have</span></span></span><span>  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>A</span></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>{is</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>disjoint</span></a></span><span> </span><span class="keyword1"><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint|const"><span>with}</span></a></span><span> </span><span class="free"><span>B</span></span><span>"</span></span></span><span>
        </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="Introduction.html#Introduction.AreDisjoint_def|fact"><span>AreDisjoint_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
    </span><span class="keyword1"><span class="command"><span>}</span></span></span><span> </span><span class="keyword3"><span class="command"><span>thus</span></span></span><span> </span><span class="var"><span class="quoted"><span class="var"><span>?thesis</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
  </span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>ultimately</span></span></span><span> </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="var"><span class="quoted"><span class="var"><span>?thesis</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><a class="entity_ref" href="../../FOL/ZF/ISABELLE_HOME/src/Provers/blast.ML.html#FOL.blast|method"><span class="operator"><span>blast</span></span></a><span>
</span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span class="quoted"><span class="plain_text"><span>‹</span><span>Overview of the project</span><span>›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span class="quoted"><span class="plain_text"><span>‹</span><span>
  </span><span>The  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Fol1›</span></span></span><span>, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> ZF1›</span></span></span><span> and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Nat_ZF_IML›</span></span></span><span> theory 
</span><span>  files contain some background material that is needed for 
</span><span>  the remaining theories.
</span><span>
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Order_ZF›</span></span></span><span> and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Order_ZF_1a›</span></span></span><span> reformulate 
</span><span>  material from standard Isabelle's 
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Order›</span></span></span><span> theory in terms of non-strict (less-or-equal) 
</span><span>  order relations.
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Order_ZF_1›</span></span></span><span> on the other hand directly continues the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Order›</span></span></span><span>
</span><span>  theory file using strict order relations (less and not equal). This is useful
</span><span>  for translating theorems from Metamath.
</span><span>
</span><span>  In </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>NatOrder_ZF›</span></span></span><span> we prove that the usual order on natural numbers
</span><span>  is linear.
</span><span>  
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>func1›</span></span></span><span> theory provides basic facts about functions.
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>func_ZF›</span></span></span><span> continues this development with more advanced
</span><span>  topics that relate to algebraic properties of binary operations, 
</span><span>  like lifting a binary operation to a function space,
</span><span>  associative, commutative and distributive operations and properties
</span><span>  of functions related to order relations. </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>func_ZF_1›</span></span></span><span> is 
</span><span>  about properties of functions related to order relations.
</span><span>
</span><span>  The standard Isabelle's </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Finite›</span></span></span><span> theory defines the finite
</span><span>  powerset of a set as a certain "datatype" (?) with some recursive
</span><span>  properties. IsarMathLib's </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Finite1›</span></span></span><span> 
</span><span>  and  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Finite_ZF_1›</span></span></span><span> theories develop more facts about this notion. 
</span><span>  These two theories are obsolete now. 
</span><span>  They will be gradually replaced by an approach based on set theory
</span><span>  rather than tools specific to Isabelle. This approach is presented
</span><span>  in </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Finite_ZF›</span></span></span><span> theory file.
</span><span>
</span><span>  In </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>FinOrd_ZF›</span></span></span><span> we talk about ordered finite sets.
</span><span>
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>EquivClass1›</span></span></span><span> theory file is a reformulation of 
</span><span>  the material in the standard
</span><span>  Isabelle's </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>EquivClass›</span></span></span><span> theory in the spirit of ZF set theory.
</span><span>  
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>FiniteSeq_ZF›</span></span></span><span> discusses the notion of finite sequences 
</span><span>  (a.k.a. lists).
</span><span>
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>InductiveSeq_ZF›</span></span></span><span> provides the definition and properties of
</span><span>  (what is known in basic calculus as) sequences defined by induction, 
</span><span>  i. e. by a formula of the form $a_0 = x,\ a_{n+1} = f(a_n)$.
</span><span>
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Fold_ZF›</span></span></span><span> shows how the familiar from functional 
</span><span>  programming notion of fold can be interpreted in set theory.
</span><span>
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Partitions_ZF›</span></span></span><span> is about splitting a set into non-overlapping
</span><span>  subsets. This is a common trick in proofs.
</span><span>
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Semigroup_ZF›</span></span></span><span> treats the expressions of the form 
</span><span>  $a_0\cdot a_1\cdot .. \cdot a_n$, (i.e. products of finite sequences), 
</span><span>  where "$\cdot$" is an associative binary operation.
</span><span>
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>CommutativeSemigroup_ZF›</span></span></span><span> is another take on a similar subject.
</span><span>  This time we consider the case when the operation is commutative
</span><span>  and the result of depends only on the set of elements we are
</span><span>  summing (additively speaking), but not the order.
</span><span>
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topology_ZF›</span></span></span><span> series covers basics of general topology: 
</span><span>  interior, closure, boundary, compact sets, separation axioms and 
</span><span>  continuous functions.
</span><span>  
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Group_ZF›</span></span></span><span>, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Group_ZF_1›</span></span></span><span>, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Group_ZF_1b›</span></span></span><span> 
</span><span>  and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Group_ZF_2›</span></span></span><span>
</span><span>  provide basic facts of the group theory. </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Group_ZF_3›</span></span></span><span> 
</span><span>  considers the notion of almost homomorphisms that is nedeed for the 
</span><span>  real numbers construction in </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Real_ZF›</span></span></span><span>.
</span><span>
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>TopologicalGroup›</span></span></span><span> connects the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topology_ZF›</span></span></span><span> and 
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Group_ZF›</span></span></span><span> series and starts the subject of topological groups
</span><span>  with some basic definitions and facts.
</span><span>
</span><span>  In </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>DirectProduct_ZF›</span></span></span><span> we define direct product of groups and show
</span><span>  some its basic properties.
</span><span>
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>OrderedGroup_ZF›</span></span></span><span> theory treats ordered groups. 
</span><span>  This is a suprisingly large theory for such relatively obscure topic.
</span><span>  
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Ring_ZF›</span></span></span><span> defines rings. </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Ring_ZF_1›</span></span></span><span> covers 
</span><span>  the properties of  rings that are specific to the real numbers construction 
</span><span>  in </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Real_ZF›</span></span></span><span>.
</span><span>
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>OrderedRing_ZF›</span></span></span><span> theory looks at the consequences of adding
</span><span>  a linear order to the ring algebraic structure.
</span><span>  
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Field_ZF›</span></span></span><span> and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>OrderedField_ZF›</span></span></span><span> contain basic facts
</span><span>  about (you guessed it) fields and ordered fields. 
</span><span>  
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Int_ZF_IML›</span></span></span><span> theory considers the integers 
</span><span>  as a monoid (multiplication) and an abelian ordered group (addition). 
</span><span>  In </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Int_ZF_1›</span></span></span><span> we show that integers form a commutative ring.
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Int_ZF_2›</span></span></span><span> contains some facts about slopes (almost homomorphisms 
</span><span>  on integers) needed for real numbers construction, 
</span><span>  used in </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Real_ZF_1›</span></span></span><span>.
</span><span>
</span><span>  In the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>IntDiv_ZF_IML›</span></span></span><span> theory we translate some properties of the 
</span><span>  integer quotient and reminder functions studied in the standard Isabelle's
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>IntDiv_ZF›</span></span></span><span> theory to the notation used in IsarMathLib.
</span><span>  
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Real_ZF›</span></span></span><span> and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Real_ZF_1›</span></span></span><span> theories 
</span><span>  contain the construction of real numbers based on the paper \cite{Arthan2004}
</span><span>  by R. D. Arthan (not Cauchy sequences, not Dedekind sections). 
</span><span>  The heavy lifting
</span><span>  is done mostly in </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Group_ZF_3›</span></span></span><span>, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Ring_ZF_1›</span></span></span><span> 
</span><span>  and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Int_ZF_2›</span></span></span><span>. </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Real_ZF›</span></span></span><span> contains 
</span><span>  the part of the construction that can be done
</span><span>  starting from generic abelian groups (rather than additive group of integers).
</span><span>  This allows to show that real numbers form a ring. 
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Real_ZF_1›</span></span></span><span> continues the construction using properties specific
</span><span>  to the integers and showing that real numbers constructed this way
</span><span>  form a complete ordered field.
</span><span>
</span><span> </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Cardinal_ZF›</span></span></span><span> provides a couple of theorems about cardinals that are mostly used for studying  
</span><span> properties of topological properties (yes, this is kind of meta). 
</span><span> The main result (proven without AC) is that if two sets can be injectively mapped into an 
</span><span> infinite cardinal, then so can be their union. 
</span><span> There is also a definition of the Axiom of Choice specific for a given cardinal 
</span><span> (so that the choice function exists for families of sets of given cardinality). 
</span><span> Some properties are proven for such predicates, like that for finite families of sets the choice 
</span><span> function always exists (in ZF) and that the axiom of choice for a larger cardinal implies 
</span><span> one for a smaller cardinal.
</span><span>
</span><span> </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Group_ZF_4›</span></span></span><span> considers conjugate of subgroup and defines simple groups. 
</span><span> A nice theorem here is that endomorphisms of an abelian group form a ring. 
</span><span> The first isomorphism theorem (a group homomorphism $h$ induces an isomorphism between the group 
</span><span> divided by the kernel of $h$ and the image of $h$) is proven.
</span><span>
</span><span> Turns out given a property of a topological space one can define a local version of a property in general. 
</span><span> This is studied in the the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topology_ZF_properties_2›</span></span></span><span> theory and applied to local 
</span><span> versions of the property of being finite or compact or Hausdorff 
</span><span> (i.e. locally finite, locally compact, locally Hausdorff).
</span><span> There are a couple of nice applications, like one-point compactification that allows to show 
</span><span> that every locally compact Hausdorff space is regular. 
</span><span> Also there are some results on the interplay between hereditability of a property and local properties.
</span><span>
</span><span>  For a given surjection $f : X\rightarrow Y$, where $X$ is a topological space one can consider the 
</span><span>  weakest topology on $Y$ which makes $f$ continuous, let's call it a quotient topology generated by $f$.  
</span><span>  The quotient topology generated by an equivalence relation r on X is actually a special case 
</span><span>  of this setup, where $f$ is the natural projection of $X$ on the quotient $X/r$. 
</span><span>  The properties of these two ways of getting new topologies are studied in </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topology_ZF_8›</span></span></span><span> 
</span><span>  theory. The main result is that any quotient topology generated by a function is homeomorphic 
</span><span>  to a topology given by an equivalence relation, so these two approaches to quotient 
</span><span>  topologies are kind of equivalent.
</span><span>
</span><span>  As we all know, automorphisms of a topological space form a group. This fact is proven in </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topology_ZF_9›</span></span></span><span> 
</span><span>  and the automorphism groups for co-cardinal, included-set, and excluded-set topologies are identified. 
</span><span>  For order topologies it is shown that order isomorphisms are homeomorphisms of the topology induced by the order. 
</span><span>  Properties preserved by continuous functions are studied and as an application it is shown 
</span><span>  for example that quotient topological spaces of compact (or connected) spaces are compact (or connected, resp.)
</span><span> 
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topology_ZF_10›</span></span></span><span> theory is about products of two topological spaces. 
</span><span>  It is proven that if two spaces are $T_0$ (or $T_1$, $T_2$, regular, connected) then their product is as well.
</span><span>
</span><span>  Given a total order on a set one can define a natural topology on it generated by taking the rays 
</span><span>  and intervals as the base. The  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topology_ZF_11›</span></span></span><span> theory studies relations between the order 
</span><span>  and various properties of generated topology. For example one can show that if the order topology 
</span><span>  is connected, then the order is complete (in the sense that for each set bounded from above the 
</span><span>  set of upper bounds has a minimum). For a given cardinal $\kappa$ we can consider 
</span><span>  generalized notion of $\kappa-separability$. Turns out $\kappa$-separability is related to (order) 
</span><span>  density of sets of cardinality $\kappa$ for order topologies.
</span><span>
</span><span>
</span><span>  Being a topological group imposes additional structure on the topology of the group, in particular 
</span><span>  its separation properties. In </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topological_Group_ZF_1.thy›</span></span></span><span> theory it is shown that if 
</span><span>  a topology is $T_0$, then it must be $T_3$ , and that the topology in a topological group 
</span><span>  is always regular.
</span><span>
</span><span>  For a given normal subgroup of a topological group we can define a topology on the quotient 
</span><span>  group in a natural way. At the end of the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topological_Group_ZF_2.thy›</span></span></span><span> theory it is shown 
</span><span>  that such topology on the quotient group makes it a topological group.
</span><span>
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Topological_Group_ZF_3.thy›</span></span></span><span> theory studies the topologies on subgroups of a 
</span><span>  topological group. A couple of nice basic properties are shown, like that the closure of a 
</span><span>  subgroup is a subgroup, closure of a normal subgroup is normal and, a bit more surprising 
</span><span>  (to me) property that every locally-compact subgroup of a $T_0$ group is closed.
</span><span>
</span><span>  In </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Complex_ZF›</span></span></span><span> we construct complex numbers starting from
</span><span>  a complete ordered field (a model of real numbers). We also define 
</span><span>  the notation for writing about complex numbers and prove that the 
</span><span>  structure of complex numbers constructed there satisfies the axioms
</span><span>  of complex numbers used in Metamath.
</span><span>
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>MMI_prelude›</span></span></span><span> defines the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>mmisar0›</span></span></span><span> context in which 
</span><span>  most theorems translated from Metamath are proven. It also contains a 
</span><span>  chapter explaining how the translation works.
</span><span>
</span><span>  In the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Metamath_interface›</span></span></span><span> theory we prove a theorem
</span><span>  that the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>mmisar0›</span></span></span><span> context is valid (can be used) 
</span><span>  in the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>complex0›</span></span></span><span> context. 
</span><span>  All theories using the translated results will import the
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Metamath_interface›</span></span></span><span> theory. The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Metamath_sampler›</span></span></span><span>
</span><span>  theory provides some examples of using the translated theorems
</span><span>  in the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>complex0›</span></span></span><span> context.
</span><span>
</span><span>  The theories </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>MMI_logic_and_sets›</span></span></span><span>, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>MMI_Complex›</span></span></span><span>, 
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>MMI_Complex_1›</span></span></span><span> and </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>MMI_Complex_2›</span></span></span><span>
</span><span>  contain the theorems imported from the
</span><span>  Metamath's set.mm database. As the translated proofs are rather verbose
</span><span>  these theories are not printed in this proof document.
</span><span>  The full list of translated facts can be found in the 
</span><span>  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Metamath_theorems.txt›</span></span></span><span> file included in the 
</span><span>  IsarMathLib distribution.
</span><span>  The </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>MMI_examples›</span></span></span><span> provides some theorems imported from Metamath
</span><span>  that are printed in this proof document as examples of how translated
</span><span>  proofs look like.</span><span>›</span></span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span></pre>
</body>

</html>